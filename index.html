<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Date Range Extension (index(2) + inline settings)</title>
  <style>
    :root {
      --w:236px; --h:200px; --gap:2px; --pad:4px; --r:8px;
      --bg:#FAFAFA; --panel:#FFFFFF; --border:#E5E7EB;
      --ink:#333333; --muted:#6B7280; --accent:#2563EB;
      --range:#E0E7FF; --disabled:#9CA3AF;
      /* previous period colors */
      --prev-range:#F4F4F4;  /* interior */
      --prev-edge:#E9E9E9;   /* first/last */
    }
    html, body { margin:0; padding:0; background:var(--bg); color:var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    .wrap { width:var(--w); height:var(--h); padding:var(--pad); box-sizing:border-box; }
    .box { position:relative; width:100%; height:100%; background:var(--panel); border:1px solid var(--border); border-radius:var(--r); padding:4px; box-sizing:border-box; display:flex; flex-direction:column; gap:2px; }
    .head { display:flex; align-items:center; justify-content:space-between; gap:4px; }
    .btn {
      all:unset; cursor:pointer; padding:0 6px; height:20px; line-height:20px;
      border-radius:6px; border:1px solid var(--border); background:#F3F4F6; color:var(--ink);
      font-size:11px; white-space:nowrap; display:flex; align-items:center; justify-content:center; text-align:center;
    }
    .btn.icon { width:22px; padding:0; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .lbl { font-size:12px; color:var(--ink); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:120px; text-align:center; cursor:pointer; }
    /* Hover affordance for month label: exact height 20px to match arrow buttons */
    #monthLabel { display:inline-flex; align-items:center; height:20px; line-height:20px; padding:0 8px; border-radius:7px; border:1px solid transparent; transition: background .12s ease, border-color .12s ease, padding .12s ease; }
    #monthLabel:hover { background:#F8F8F8; border-color:var(--border); padding:0 12px; } /* bigger horizontally; height unchanged */
    .gear { all:unset; width:22px; height:20px; line-height:20px; border:1px solid var(--border); background:#F3F4F6; border-radius:6px; text-align:center; cursor:pointer; display:none; }
    .grid { display:grid; grid-template-columns: repeat(7, 1fr); gap:var(--gap); }
    #dow { padding-top:4px; }
    .dow { font-size:10px; color:var(--muted); text-align:center; padding:2px 0; }
    .cell {
      position:relative; font-size:11px; text-align:center; line-height:18px; height:18px;
      border-radius:6px; user-select:none; border:1px solid transparent; color:var(--ink);
    }
    .cell:hover { outline:2px solid rgba(37,99,235,.2); }
    .cell.disabled { color: var(--disabled); pointer-events:none; outline:none; }
    .in-range { background: var(--range); }
    .start, .end { background: var(--accent); color:#fff; font-weight:700; }
    .start { border-top-left-radius:8px; border-bottom-left-radius:8px; }
    .end   { border-top-right-radius:8px; border-bottom-right-radius:8px; }
    /* previous period styling */
    .prev-range { background: var(--prev-range); }
    .prev-start, .prev-end { background: var(--prev-edge); font-weight:600; }
    .prev-start { border-top-left-radius:8px; border-bottom-left-radius:8px; }
    .prev-end   { border-top-right-radius:8px; border-bottom-right-radius:8px; }
    .cell.today::after { content:''; position:absolute; inset:2px; border:1px dashed var(--accent); border-radius:5px; pointer-events:none; }
    .foot { display:flex; gap:4px; justify-content:space-between; margin-top:0px; flex-wrap:wrap; }
    .foot .btn { flex:1; font-size:10px; height:20px; line-height:20px; }

    /* Inline settings panel (overlay) */
    .panel {
      position:absolute;
      left:8px; right:8px; bottom:-12px;
      background:#fff; border:1px solid var(--border);
      border-radius:10px; padding:10px; box-shadow:0 6px 20px rgba(0,0,0,.08);
      display:none; z-index:10; max-height:calc(var(--h) - 16px); overflow:auto;
    }
    .panel.show { display:block; }
    .row { display:flex; gap:8px; margin-top:6px; }
    label { display:block; font-size:11px; color:#374151; margin:0 0 4px; }
    select, input[type="checkbox"], input[type="text"], input[type="number"] { box-sizing:border-box; }
    select, input[type="text"], input[type="number"] { width:100%; border:1px solid #E5E7EB; border-radius:6px; padding:4px 6px; font-size:12px; background:#fff; }
    input[type="number"] { -moz-appearance: textfield; }
    .panel .btns { display:flex; gap:8px; justify-content:flex-end; margin-top:8px; }
    .panel .btns #saveCfg { background:#D4EEC8; border-color:#D4EEC8; }
    .toggle { display:flex; align-items:center; gap:8px; font-size:12px; color:#111827; margin-top:8px; }

    /* Buttons config list */
    .btncfg { margin-top:8px; border-top:1px dashed var(--border); padding-top:8px; }
    .btncfg h4 { margin:0 0 6px; font-size:12px; color:#111827; }

    /* Config rows */
    .btnrow { display:grid; grid-template-columns: 1fr 40px 20px; gap:6px; align-items:center; margin-bottom:6px; }
    .btnrow input.btnLabel { width:100%; height:24px; }
    .btnrow input.btnDays  { width:40px; height:24px; padding-right:4px; padding-left:6px; }
    .btnrow .btn { height:20px; line-height:20px; font-size:14px; font-weight:700; padding:0; width:20px; min-width:20px; border-radius:6px; }
    .btnrow .del { background:#FEE2E2; border-color:#FCA5A5; }
    .btnrow .del:hover { filter:brightness(0.98); }

    .btnadd { display:grid; grid-template-columns: 1fr 40px 20px; gap:6px; align-items:center; }
    .btnadd input#newBtnLabel { width:100%; height:24px; }
    .btnadd input#newBtnDays  { width:40px; height:24px; }
    .btnadd .btn#addBtn { height:20px; width:20px; min-width:20px; line-height:20px; font-size:16px; font-weight:700; padding:0; background:#ECFDF5; border-color:#A7F3D0; }

    /* Month picker popup */
    .monthpicker {
      position:absolute; left:8px; right:8px; top:26px;
      background:#fff; border:1px solid var(--border); border-radius:10px;
      box-shadow:0 6px 20px rgba(0,0,0,.08); padding:8px; display:none; z-index:12;
    }
    .monthpicker.show { display:block; }
    .mp-head { display:flex; align-items:center; justify-content:space-between; gap:6px; margin-bottom:6px; }
    .mp-year { font-size:12px; font-weight:600; }
    .mp-grid { display:grid; grid-template-columns: repeat(4, 1fr); gap:6px; }
    .mp-cell {
      all:unset; position:relative; display:flex; align-items:center; justify-content:center;
      height:22px; line-height:22px; border:1px solid var(--border); border-radius:6px;
      cursor:pointer; font-size:11px; background:#F9FAFB; text-align:center; overflow:hidden;
    }
    .mp-cell:hover { outline:2px solid rgba(37,99,235,.2); }
    .mp-cell.active { background:var(--range); border-color:var(--accent); }
    /* dashed outline for the CURRENT (real) month */
    .mp-cell.current::after {
      content:''; position:absolute; inset:2px; border:1px dashed var(--accent); border-radius:5px; pointer-events:none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="box">
      <div class="head">
        <button class="btn icon" id="prev">‹</button>
        <div class="lbl" id="monthLabel"></div>
        <button class="btn icon" id="next">›</button>
        <button class="gear" id="cfg" title="Настройки">⚙︎</button>
      </div>

      <!-- Month picker popup -->
      <div class="monthpicker" id="monthPicker" aria-hidden="true">
        <div class="mp-head">
          <button class="btn icon" id="mpPrevY" aria-label="Prev year">‹</button>
          <div class="mp-year" id="mpYearLabel">2025</div>
          <button class="btn icon" id="mpNextY" aria-label="Next year">›</button>
        </div>
        <div class="mp-grid" id="mpGrid"></div>
      </div>

      <div class="grid" id="dow"></div>
      <div class="grid" id="grid"></div>
      <div class="foot" id="footBtns"></div>

      <!-- Settings panel -->
      <div class="panel" id="settingsPanel" aria-hidden="true">
        <div class="row" style="margin-top:0">
          <div style="flex:1">
            <label for="startParamName">Start param</label>
            <select id="startParamName"></select>
          </div>
          <div style="flex:1">
            <label for="endParamName">End param</label>
            <select id="endParamName"></select>
          </div>
        </div>
        <div class="row">
          <div style="flex:1">
            <label for="rangeParamName">Range param</label>
            <select id="rangeParamName"></select>
          </div>
          <div style="flex:1">
            <label for="calendarLang">Язык календаря</label>
            <select id="calendarLang">
              <option value="ru">Русский</option>
              <option value="en">English</option>
            </select>
          </div>
        </div>
        <div class="toggle">
          <input type="checkbox" id="showPrevPeriod" />
          <label for="showPrevPeriod" style="margin:0;">Предыдущий период</label>
        </div>

        <div class="btncfg">
          <h4>Пресеты (последние N дней)</h4>
          <div id="btnList"></div>
          <div class="btnadd">
            <input type="text" id="newBtnLabel" placeholder="Название кнопки (например, Последние 7 дней)" />
            <input type="number" id="newBtnDays" min="1" value="7" />
            <button class="btn add" id="addBtn" aria-label="Добавить">+</button>
          </div>
        </div>

        <div class="btns">
          <button class="btn" id="cancelCfg">Отмена</button>
          <button class="btn" id="saveCfg">Сохранить</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // --- loader ---
    const loadScript = (src) => new Promise((res, rej)=>{ const s=document.createElement('script'); s.src=src; s.onload=()=>res(src); s.onerror=()=>rej(new Error('Fail '+src)); document.head.appendChild(s); });
    async function ensureAPI(){
      try{ await loadScript('./tableau.extensions.1.latest.js'); if (window.tableau && tableau.extensions) return; }catch(_){}
      try{ await loadScript('https://tableau.github.io/extensions-api/lib/tableau.extensions.1.latest.js'); }catch(_){}
    }

    // --- defaults ---
    const DEFAULTS = {
      startParamName: 'StartDate',
      endParamName:   'EndDate',
      sheetName:      'dt_sheet',
      fieldName:      'dt',
      rangeParamName: 'MinMaxDate',
      settingsParamName: '',
      showPrevPeriod: false,
      calendarLang: 'ru', // 'ru' | 'en'  (affects only calendar)
      initialPreset:  'params',
      styles: {
        pageBg:  '#FAFAFA',
        panelBg: '#FFFFFF',
        text:    '#333333',
        accent:  '#2563EB',
        border:  '#E5E7EB'
      },
      buttonsMarginTopPx: 0,
      quickButtons: [
        { label: 'Сегодня', days: 1 },
        { label: 'Последние 30 дней', days: 30 }
      ]
    };

    // --- cached DOM refs ---
    const DOW = document.getElementById('dow');
    const GRID = document.getElementById('grid');
    const FOOT = document.getElementById('footBtns');
    const MONTH = document.getElementById('monthLabel');
    const BTN_PREV = document.getElementById('prev');
    const BTN_NEXT = document.getElementById('next');
    const BTN_CFG  = document.getElementById('cfg');
    const MP       = document.getElementById('monthPicker');
    const MP_YEAR  = document.getElementById('mpYearLabel');
    const MP_GRID  = document.getElementById('mpGrid');

    // --- helpers ---
    function getLocale(lang){ return lang === 'en' ? 'en-US' : 'ru-RU'; }
    function getDOW(lang){
      return lang === 'en'
        ? ['Mon','Tue','Wed','Thu','Fri','Sat','Sun']
        : ['Пн','Вт','Ср','Чт','Пт','Сб','Вс'];
    }
    function monthName(i, lang, type='long'){
      const locale=getLocale(lang);
      const name=new Date(2000, i, 1).toLocaleString(locale, {month:type});
      return (lang==='ru') ? (name.charAt(0).toUpperCase()+name.slice(1)) : name;
    }
    function monthShortName(i, lang){
      if (lang === 'ru'){
        return ['Янв','Фев','Мар','Апр','Май','Июн','Июл','Авг','Сен','Окт','Ноя','Дек'][i] || '';
      } else {
        return new Date(2000, i, 1).toLocaleString('en-US', {month:'short'});
      }
    }
    function updateMonthLabelTitle(lang){
      MONTH.title = (lang === 'en') ? 'Click or Scroll to change the month' : 'Нажмите или Прокрутите для смены месяца';
    }
    const $ = (q)=>document.querySelector(q);
    const pad2 = (n)=> (n<10 ? '0'+n : ''+n);
    const fmt = (d)=> `${pad2(d.getDate())}.${pad2(d.getMonth()+1)}.${d.getFullYear()}`;
    const fmtRange = (a,b)=> `${fmt(a)} - ${fmt(b)}`;

    function clipNoon(d){ if (!d) return d; return new Date(d.getFullYear(), d.getMonth(), d.getDate(), 12,0,0,0); }
    function applyTheme(cfg){
      document.documentElement.style.setProperty('--bg', cfg.styles.pageBg);
      document.documentElement.style.setProperty('--panel', cfg.styles.panelBg);
      document.documentElement.style.setProperty('--ink', cfg.styles.text);
      document.documentElement.style.setProperty('--accent', cfg.styles.accent);
      document.documentElement.style.setProperty('--border', cfg.styles.border);
      FOOT.style.marginTop = (cfg.buttonsMarginTopPx||0) + 'px';
    }
    function getSettings(){
      try{
        const raw = tableau.extensions.settings.get('cfg');
        if (!raw) return {...DEFAULTS};
        const j = JSON.parse(raw);
        const merged = {...DEFAULTS, ...j, styles: {...DEFAULTS.styles, ...(j.styles||{})}};
        if (!Array.isArray(merged.quickButtons)){
          merged.quickButtons = [...DEFAULTS.quickButtons];
        }
        merged.quickButtons = merged.quickButtons
          .map(b => ({label: String(b.label||'').trim() || 'Кнопка', days: Math.max(1, parseInt(b.days||1, 10)||1)}));
        if (!merged.calendarLang) merged.calendarLang = 'ru';
        return merged;
      }catch{ return {...DEFAULTS}; }
    }
    function setSettings(cfg){
      try{
        tableau.extensions.settings.set('cfg', JSON.stringify(cfg));
        return tableau.extensions.settings.saveAsync();
      }catch{ return Promise.resolve(); }
    }

    // --- core state ---
    let CFG = {...DEFAULTS};
    let startParam=null, endParam=null;
    let startDate=null, endDate=null;
    let allowMin=null, allowMax=null, allowMinTs=null, allowMaxTs=null;
    let viewYear, viewMonth;
    let mpYear = new Date().getFullYear();

    // Wheel sensitivity control (normal mapping: up -> previous, down -> next)
    let wheelAccum = 0;
    let lastWheelShift = 0;
    const WHEEL_THRESHOLD = 120;
    const WHEEL_COOLDOWN_MS = 160;

    function setAllowedRange(lo, hi){
      allowMin = lo ? clipNoon(lo) : null;
      allowMax = hi ? clipNoon(hi) : null;
      allowMinTs = allowMin ? +allowMin : null;
      allowMaxTs = allowMax ? +allowMax : null;
    }
    function inAllowed(d){ const t=+(d instanceof Date ? clipNoon(d) : new Date(d)); if (allowMinTs!=null && t<allowMinTs) return false; if (allowMaxTs!=null && t>allowMaxTs) return false; return true; }
    function clampToAllowed(d){ if (!d) return d; const t=+(d instanceof Date ? clipNoon(d) : new Date(d)); if (allowMinTs!=null && t<allowMinTs) return new Date(allowMinTs); if (allowMaxTs!=null && t>allowMaxTs) return new Date(allowMaxTs); return new Date(t); }

    function buildDOW(){
      const days = getDOW(CFG.calendarLang);
      DOW.innerHTML='';
      const frag=document.createDocumentFragment();
      for(const x of days){ const e=document.createElement('div'); e.className='dow'; e.textContent=x; frag.appendChild(e); }
      DOW.appendChild(frag);
    }

    function renderFooterButtons(){
      FOOT.innerHTML='';
      const frag=document.createDocumentFragment();
      (CFG.quickButtons||[]).forEach((b, idx)=>{
        const btn = document.createElement('button');
        btn.className='btn';
        btn.textContent = b.label;
        btn.dataset.days = String(Math.max(1, parseInt(b.days||1,10)||1));
        btn.dataset.idx = String(idx);
        frag.appendChild(btn);
      });
      FOOT.appendChild(frag);
    }

    function render(){
      const d1 = new Date(viewYear, viewMonth, 1);
      let label = d1.toLocaleString(getLocale(CFG.calendarLang), {month:'long', year:'numeric'});
      if (CFG.calendarLang === 'ru') label = label.charAt(0).toUpperCase()+label.slice(1);
      MONTH.textContent = label;
      updateMonthLabelTitle(CFG.calendarLang);

      GRID.innerHTML='';
      const frag=document.createDocumentFragment();
      const dow = d1.getDay() || 7;
      const offset = dow - 1;
      for(let i=0;i<offset;i++){ const x=document.createElement('div'); x.className='cell'; x.style.visibility='hidden'; frag.appendChild(x); }

      const days = new Date(viewYear, viewMonth+1, 0).getDate();
      const today = clipNoon(new Date()); const todayTs=+today;

      // prev period boundaries
      let prevStart=null, prevEnd=null, prevStartTs=null, prevEndTs=null;
      if (CFG.showPrevPeriod && startDate && endDate){
        const diffDays = Math.round((+endDate - +startDate) / 86400000);
        prevEnd = clipNoon(new Date(startDate)); prevEnd.setDate(prevEnd.getDate() - 1); prevEndTs=+prevEnd;
        prevStart = clipNoon(new Date(startDate)); prevStart.setDate(prevStart.getDate() - diffDays - 1); prevStartTs=+prevStart;
      }

      // Prepare tooltip text for cells
      let tipText = '';
      if (startDate){
        const a = startDate;
        const b = endDate ? endDate : startDate;
        const sel = fmtRange(a,b);
        if (CFG.calendarLang === 'en'){
          if (CFG.showPrevPeriod && endDate){
            const prev = fmtRange(prevStart, prevEnd);
            tipText = `Current period: ${sel}
Previous period: ${prev}`;
          } else {
            tipText = `Selected period: ${sel}`;
          }
        } else {
          if (CFG.showPrevPeriod && endDate){
            const prev = fmtRange(prevStart, prevEnd);
            tipText = `Текущий период: ${sel}
Предыдущий период: ${prev}`;
          } else {
            tipText = `Выбранный период: ${sel}`;
          }
        }
      }

      for(let d=1; d<=days; d++){
        const dt=clipNoon(new Date(viewYear, viewMonth, d)); const ts=+dt;
        const el=document.createElement('div'); el.className='cell'; el.textContent=d; el.dataset.ts=String(ts);
        if (tipText) el.title = tipText;

        const disabled = !inAllowed(ts);
        if (disabled) { el.classList.add('disabled'); el.setAttribute('aria-disabled','true'); }
        if (ts===todayTs) el.classList.add('today');

        // current selection
        if (!disabled){
          if (startDate && endDate){
            const a=+startDate, b=+endDate;
            if (ts>a && ts<b) el.classList.add('in-range');
            if (ts===a) el.classList.add('start');
            if (ts===b) el.classList.add('end');
          } else if (startDate && ts===+startDate) el.classList.add('start');
        }

        // previous period shading
        if (!disabled && prevStart && prevEnd){
          if (ts>prevStartTs && ts<prevEndTs) el.classList.add('prev-range');
          if (ts===prevStartTs) el.classList.add('prev-start');
          if (ts===prevEndTs) el.classList.add('prev-end');
        }
        frag.appendChild(el);
      }
      GRID.appendChild(frag);

      BTN_PREV.disabled = false; BTN_NEXT.disabled = false;
      renderFooterButtons();
    }

    function normalize(){ if (startDate && endDate && startDate > endDate) [startDate, endDate] = [endDate, startDate]; }

    async function writeParams(){
      if (!startParam || !endParam) return;
      try{
        await Promise.all([
          startParam.changeValueAsync(new Date(startDate)),
          endParam.changeValueAsync(new Date(endDate))
        ]);
      }catch(_){}
    }

    function onPick(date, disabled){
      if (disabled || !inAllowed(date)) return;
      if (!startDate || (startDate && endDate)) {
        startDate=clipNoon(date); endDate=null;
      } else {
        endDate=clipNoon(date); normalize();
        writeParams();
      }
      render();
    }

    // --- Month picker + wheel ---
    function openMonthPicker(){
      mpYear = viewYear;
      MP_YEAR.textContent = String(mpYear);
      MP.classList.add('show');
      MP.setAttribute('aria-hidden', 'false');
      buildMonthGrid();
    }
    function closeMonthPicker(){
      MP.classList.remove('show');
      MP.setAttribute('aria-hidden', 'true');
    }
    function toggleMonthPicker(){
      if (MP.classList.contains('show')) closeMonthPicker(); else openMonthPicker();
    }
    function buildMonthGrid(){
      MP_GRID.innerHTML='';
      const frag=document.createDocumentFragment();
      const now = new Date();
      for (let m=0; m<12; m++){
        const btn=document.createElement('button');
        let cls='mp-cell';
        if (m===viewMonth && mpYear===viewYear) cls+=' active';
        if (m===now.getMonth() && mpYear===now.getFullYear()) cls+=' current';
        btn.className=cls;
        const shortLabel = monthShortName(m, CFG.calendarLang);
        const fullLabel  = monthName(m, CFG.calendarLang, 'long');
        btn.textContent = shortLabel;
        btn.title = fullLabel;
        btn.dataset.m = String(m);
        frag.appendChild(btn);
      }
      MP_GRID.appendChild(frag);
    }
    function shiftMonth(delta){
      let y=viewYear, m=viewMonth + delta;
      while (m<0){ m+=12; y--; }
      while (m>11){ m-=12; y++; }
      viewYear=y; viewMonth=m; render();
    }

    // --- Settings helpers ---
    async function getRangeFromWorksheet(sheetName, fieldName){
      try{
        const dashboard = tableau.extensions.dashboardContent.dashboard;
        const sheet = dashboard.worksheets.find(w => w.name === sheetName);
        if (!sheet) return [null, null];
        const data = await sheet.getSummaryDataAsync({ignoreSelection: true});
        const idx = data.columns.findIndex(c => c.fieldName === fieldName || c.alias === fieldName);
        if (idx === -1) return [null, null];
        let min=null, max=null;
        for (const row of data.data){
          const v = row[idx].value;
          if (!v) continue;
          const raw = (v instanceof Date) ? v : new Date(v);
          const d = clipNoon(raw);
          if (isNaN(+d)) continue;
          if (!min || d < min) min = d;
          if (!max || d > max) max = d;
        }
        return [min, max];
      } catch(e){ return [null, null]; }
    }

    function toggleSettings(show){
      const p=document.getElementById('settingsPanel'); if (!p) return;
      if (show) closeMonthPicker();
      p.classList.toggle('show', !!show);
      p.setAttribute('aria-hidden', show?'false':'true');
    }
    function makeBtnRow(label, days){
      const row = document.createElement('div');
      row.className='btnrow';
      const i1 = document.createElement('input'); i1.type='text'; i1.className='btnLabel'; i1.value = label || ''; i1.placeholder='Название';
      const i2 = document.createElement('input'); i2.type='number'; i2.className='btnDays'; i2.min='1'; i2.value = String(Math.max(1, parseInt(days||1,10)||1));
      const del = document.createElement('button'); del.className='btn del'; del.textContent='−'; del.setAttribute('aria-label','Удалить');
      del.addEventListener('click', ()=> row.remove());
      row.appendChild(i1); row.appendChild(i2); row.appendChild(del);
      return row;
    }
    function loadButtonsToUI(){
      const list = document.getElementById('btnList');
      list.innerHTML='';
      (CFG.quickButtons||[]).forEach(b=>{
        list.appendChild(makeBtnRow(b.label, b.days));
      });
      const langSel = document.getElementById('calendarLang');
      if (langSel) langSel.value = CFG.calendarLang || 'ru';
    }

    async function openInlineSettings(){
      try{
        const isAuthoring = tableau.extensions?.environment?.mode === tableau.ExtensionMode.Authoring;
        if (!isAuthoring) return;
        const dash = tableau.extensions.dashboardContent.dashboard;
        const params = await dash.getParametersAsync();
        const names = params.map(p=>p.name);

        const s=document.getElementById('startParamName'), e=document.getElementById('endParamName'), r=document.getElementById('rangeParamName');
        s.innerHTML=''; e.innerHTML=''; r.innerHTML='';
        for (const n of names){
          const o1=document.createElement('option'); o1.value=o1.textContent=n; s.appendChild(o1);
          const o2=document.createElement('option'); o2.value=o2.textContent=n; e.appendChild(o2);
          const o3=document.createElement('option'); o3.value=o3.textContent=n; r.appendChild(o3);
        }
        if (names.includes(CFG.startParamName)) s.value=CFG.startParamName;
        if (names.includes(CFG.endParamName))   e.value=CFG.endParamName;
        if (names.includes(CFG.rangeParamName)) r.value=CFG.rangeParamName;
        else if (names.includes('MinMaxDate'))  r.value='MinMaxDate';

        const chk = document.getElementById('showPrevPeriod');
        if (chk) chk.checked = !!CFG.showPrevPeriod;

        loadButtonsToUI();

        const addBtn = document.getElementById('addBtn');
        const newLabel = document.getElementById('newBtnLabel');
        const newDays  = document.getElementById('newBtnDays');
        addBtn.onclick = ()=>{
          const label = (newLabel.value||'').trim() || 'Кнопка';
          const days = Math.max(1, parseInt(newDays.value||'1',10)||1);
          document.getElementById('btnList').appendChild(makeBtnRow(label, days));
          newLabel.value=''; newDays.value='7';
        };
      }catch(e){ console.warn('Не удалось получить параметры', e); }
      toggleSettings(true);
    }

    async function initInsideTableau(){
      CFG = getSettings();
      applyTheme(CFG);

      try{
        const isAuthoring = tableau.extensions?.environment?.mode === tableau.ExtensionMode.Authoring;
        if (isAuthoring) BTN_CFG.style.display = 'inline-block';
      }catch(_){}

      const params = await tableau.extensions.dashboardContent.dashboard.getParametersAsync();
      startParam = params.find(p => p.name===CFG.startParamName);
      endParam   = params.find(p => p.name===CFG.endParamName);

      // allowed range from param or worksheet
      const [pLo, pHi] = await getRangeFromParam(CFG.rangeParamName || 'MinMaxDate');
      if (pLo && pHi){ setAllowedRange(pLo, pHi); }
      else {
        const [wLo, wHi] = await getRangeFromWorksheet(CFG.sheetName, CFG.fieldName);
        setAllowedRange(wLo, wHi);
      }

      // initial values from params
      const minV = startParam?.currentValue?.value ? clipNoon(new Date(startParam.currentValue.value)) : null;
      const maxV = endParam?.currentValue?.value ? clipNoon(new Date(endParam.currentValue.value)) : null;
      startDate = clampToAllowed(minV);
      endDate   = clampToAllowed(maxV);
      if (!(startDate||endDate)){ const now=new Date(); startDate=clipNoon(now); endDate=clipNoon(now); }
      if (startDate && endDate && startDate > endDate) [startDate, endDate] = [endDate, startDate];

      const base = endDate || startDate || (allowMin || clipNoon(new Date()));
      viewYear=base.getFullYear(); viewMonth=base.getMonth();

      BTN_CFG.addEventListener('click', openInlineSettings);
      document.getElementById('cancelCfg').addEventListener('click', ()=> toggleSettings(false));
      document.getElementById('saveCfg').addEventListener('click', async ()=>{
        const sEl=document.getElementById('startParamName'), eEl=document.getElementById('endParamName'), rEl=document.getElementById('rangeParamName');
        const chk = document.getElementById('showPrevPeriod');
        const langSel = document.getElementById('calendarLang');

        // collect buttons
        const rows = Array.from(document.querySelectorAll('#btnList .btnrow'));
        const qb = rows.map(r=>{
          const label = (r.querySelector('.btnLabel')?.value || '').trim() || 'Кнопка';
          const days  = Math.max(1, parseInt(r.querySelector('.btnDays')?.value || '1',10)||1);
          return { label, days };
        });

        CFG.startParamName = sEl?.value || CFG.startParamName;
        CFG.endParamName   = eEl?.value || CFG.endParamName;
        CFG.rangeParamName = rEl?.value || CFG.rangeParamName;
        CFG.showPrevPeriod = !!(chk && chk.checked);
        CFG.calendarLang   = (langSel?.value === 'en') ? 'en' : 'ru';
        CFG.quickButtons   = qb.length ? qb : [...DEFAULTS.quickButtons];

        await setSettings(CFG);

        try{
          const params2 = await tableau.extensions.dashboardContent.dashboard.getParametersAsync();
          startParam = params2.find(p => p.name===CFG.startParamName);
          endParam   = params2.find(p => p.name===CFG.endParamName);
          const [lo, hi] = await getRangeFromParam(CFG.rangeParamName || 'MinMaxDate');
          if (lo && hi) setAllowedRange(lo, hi);
          startDate = clampToAllowed(startDate);
          endDate   = clampToAllowed(endDate);
        }catch{}
        buildDOW(); render();
        toggleSettings(false);
      });

      tableau.extensions.settings.addEventListener(tableau.TableauEventType.SettingsChanged, ()=>{
        CFG = getSettings(); applyTheme(CFG); buildDOW(); render();
      });

      buildDOW(); render();

      // Wheel on month label (up -> previous, down -> next) with threshold & cooldown
      MONTH.addEventListener('wheel', (e)=>{
        e.preventDefault();
        wheelAccum += (e.deltaY || 0);
        const now = performance.now();
        if (now - lastWheelShift < WHEEL_COOLDOWN_MS) return;
        if (wheelAccum >= WHEEL_THRESHOLD) {
          shiftMonth(+1); // down -> next
          lastWheelShift = now; wheelAccum = 0;
        } else if (wheelAccum <= -WHEEL_THRESHOLD) {
          shiftMonth(-1); // up -> previous
          lastWheelShift = now; wheelAccum = 0;
        }
        if (MP.classList.contains('show')) {
          mpYear = viewYear; MP_YEAR.textContent = String(mpYear); buildMonthGrid();
        }
      }, {passive:false});

      // Click to open month picker
      MONTH.addEventListener('click', toggleMonthPicker);
    }

    async function boot(){
      await ensureAPI();
      if (!(window.tableau && tableau.extensions)){
        BTN_CFG.addEventListener('click', ()=>alert('Откройте в Tableau, чтобы настраивать расширение.'));
        const now=new Date(); viewYear=now.getFullYear(); viewMonth=now.getMonth(); buildDOW(); render();

        // Local-only wheel + picker
        MONTH.addEventListener('wheel', (e)=>{
          e.preventDefault();
          wheelAccum += (e.deltaY || 0);
          const t = performance.now();
          if (t - lastWheelShift < WHEEL_COOLDOWN_MS) return;
          if (wheelAccum >= WHEEL_THRESHOLD) { shiftMonth(+1); lastWheelShift = t; wheelAccum = 0; }
          else if (wheelAccum <= -WHEEL_THRESHOLD) { shiftMonth(-1); lastWheelShift = t; wheelAccum = 0; }
        }, {passive:false});
        MONTH.addEventListener('click', toggleMonthPicker);
        document.getElementById('mpPrevY').addEventListener('click', ()=>{ mpYear--; MP_YEAR.textContent=String(mpYear); buildMonthGrid(); });
        document.getElementById('mpNextY').addEventListener('click', ()=>{ mpYear++; MP_YEAR.textContent=String(mpYear); buildMonthGrid(); });
        MP_GRID.addEventListener('click', (e)=>{
          const cell = e.target.closest('.mp-cell'); if (!cell) return;
          const m = parseInt(cell.dataset.m||'0',10)||0;
          viewMonth=m; viewYear=mpYear; render(); closeMonthPicker();
        });
        document.addEventListener('keydown', (e)=>{ if (e.key==='Escape') closeMonthPicker(); });
        document.addEventListener('click', (e)=>{
          if (MP.classList.contains('show') && !MP.contains(e.target) && e.target!==MONTH) closeMonthPicker();
        });
        return;
      }
      try{
        await tableau.extensions.initializeAsync();
        await initInsideTableau();

        // Month picker wiring (Tableau context)
        document.getElementById('mpPrevY').addEventListener('click', ()=>{ mpYear--; MP_YEAR.textContent=String(mpYear); buildMonthGrid(); });
        document.getElementById('mpNextY').addEventListener('click', ()=>{ mpYear++; MP_YEAR.textContent=String(mpYear); buildMonthGrid(); });
        MP_GRID.addEventListener('click', (e)=>{
          const cell = e.target.closest('.mp-cell'); if (!cell) return;
          const m = parseInt(cell.dataset.m||'0',10)||0;
          viewMonth=m; viewYear=mpYear; render(); closeMonthPicker();
        });
        document.addEventListener('keydown', (e)=>{ if (e.key==='Escape') closeMonthPicker(); });
        document.addEventListener('click', (e)=>{
          if (MP.classList.contains('show') && !MP.contains(e.target) && e.target!==MONTH) closeMonthPicker();
        });

      }catch(e){ console.error(e);
        const now=new Date(); viewYear=now.getFullYear(); viewMonth=now.getMonth(); buildDOW(); render();
      }
    }

    // Event delegation for calendar + presets
    document.addEventListener('click', async (e)=>{
      // prev/next month
      if (e.target.id==='prev'){
        const y = viewYear + (viewMonth===0 ? -1 : 0);
        const m = viewMonth===0 ? 11 : (viewMonth-1);
        viewYear=y; viewMonth=m; render();
        return;
      }
      if (e.target.id==='next'){
        const y = viewYear + (viewMonth===11 ? 1 : 0);
        const m = viewMonth===11 ? 0 : (viewMonth+1);
        viewYear=y; viewMonth=m; render();
        return;
      }
      // calendar cell click
      const cell = e.target.closest('.cell');
      if (cell && cell.dataset.ts){
        if (!cell.classList.contains('disabled')){
          onPick(new Date(Number(cell.dataset.ts)), false);
        }
        return;
      }
      // quick buttons
      const qbtn = e.target.closest('#footBtns .btn');
      if (qbtn && qbtn.dataset.days){
        const n = Math.max(1, parseInt(qbtn.dataset.days||'1',10)||1);
        const now = clipNoon(new Date());
        const start = clipNoon(new Date(now.getFullYear(), now.getMonth(), now.getDate() - (n-1)));
        startDate = clampToAllowed(start);
        endDate   = clampToAllowed(now);
        viewYear = endDate.getFullYear(); viewMonth = endDate.getMonth();
        render();
        await writeParams();
        return;
      }
    });

    // --- helpers for range param ---
    async function getRangeFromParam(paramName){
      try{
        const dashboard = tableau.extensions.dashboardContent.dashboard;
        const params = await dashboard.getParametersAsync();
        const p = params.find(x => x.name === paramName);
        const raw = p?.currentValue?.value;
        if (!raw || typeof raw !== 'string') return [null, null];
        const [loStr, hiStr] = raw.split('|').map(s => (s||'').trim());
        const lo = new Date(loStr), hi = new Date(hiStr);
        if (isNaN(+lo) || isNaN(+hi)) return [null, null];
        lo.setHours(12,0,0,0); hi.setHours(12,0,0,0);
        return [lo, hi];
      } catch(e){ console.warn('getRangeFromParam failed', e); return [null, null]; }
    }

    // Boot
    boot();
  </script>
</body>
</html>
